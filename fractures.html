<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>cannon.js mouse pick demo</title>
		<style>
      html, body {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
      #container {
        position: absolute;
        z-index: 1;
      }
      #options {
        background-color: transparent;
        position: absolute;
        z-index: 2;
        top: 0;
        right: 0;
        color: white;
        width: 220px;
      }
      ul {
        list-style: none;
        margin-top: 10px;
      }
      li {
        border-radius: 5px;
        border: 1px solid #888899;
        height: 50px;
        width: 50px;
        padding: 10px;
        float: left;
        margin-left: 10px;
        cursor: pointer;
      }
      li:hover {
        background-color: rgba(255,255,150, .2);
      }
      .option-set {
        position: relative;
      }
		</style>
	</head>
	<body>

		<div id="container">

		</div>
		<div id="options">
			<div>
				<div class="option-set">
					Scenes
				</div>
				<ul id="scene-list">
					<li>
						Cubes
					</li>
					<li>
						Pillars
					</li>
				</ul>
			</div>
			<div>
				<div class="option-set">
					Templates
				</div>
				<ul id="fracture-list">
					<li>
						Plane
					</li>
					<li>
						Sphere
					</li>
				</ul>
			</div>
		</div>

		<script src="js/libs/jquery.js"></script>
		<script src="js/libs/Three.js"></script>
		<script src="js/libs/Detector.js"></script>
		<script src="js/libs/cannon.js"></script>

		<script>
      $('#scene-list li').click(function(e) {
        e.stopPropagation();
        setScene($.trim(e.target.textContent));
      });

      $('#fracture-list li').click(function(e) {
        e.stopPropagation();
        setFracturePattern($.trim(e.target.textContent));
      });

      var world;
      var dt = 1 / 60;

      var constraintDown = false;
      var camera, scene, renderer, gplane = false, fracturePattern = false;
      var geometry, material, mesh;
      var controls, time = Date.now();

      var jointBody, constrainedBody, mouseConstraint;

      var n_cubes = 3;

      var container, camera, scene, renderer, projector, loader;

      // To be synced
      var meshes = [], bodies = [];

      // Initialize Three.js
      if (!Detector.webgl) {
        Detector.addGetWebGLMessage();
      }

      initCannon();
      init();
      animate();

      function init() {

        projector = new THREE.Projector();

        container = document.getElementById('container');

        loader = new THREE.JSONLoader();

        // scene
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 500, 10000);

        // camera
        camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.5, 10000);
        camera.position.set(10, 2, 0);
        camera.quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 2);
        camera.name = "perspective camera";
        scene.add(camera);

        // lights
        var light, materials;
        var temp_light = new THREE.AmbientLight(0x666666);
        temp_light.name = "ambient light";
        scene.add(temp_light);

        light = new THREE.DirectionalLight(0xffffff, 1.75);
        light.name = "directional light";
        var d = 20;

        light.position.set(d, d, d);

        light.castShadow = true;
        //light.shadowCameraVisible = true;

        light.shadowMapWidth = 1024;
        light.shadowMapHeight = 1024;

        light.shadowCameraLeft = -d;
        light.shadowCameraRight = d;
        light.shadowCameraTop = d;
        light.shadowCameraBottom = -d;

        light.shadowCameraFar = 3 * d;
        light.shadowCameraNear = d;
        light.shadowDarkness = 0.5;

        scene.add(light);

        // floor
        geometry = new THREE.PlaneGeometry(100, 100, 1, 1);
        //geometry.applyMatrix( new THREE.Matrix4().makeRotationX( -Math.PI / 2 ) );
        material = new THREE.MeshLambertMaterial({
          color : 0x777777
        });
        markerMaterial = new THREE.MeshLambertMaterial({
          color : 0xff0000,
          side : THREE.DoubleSide,
          transparent : true,
          opacity: 0.6,
        });
        //THREE.ColorUtils.adjustHSV( material.color, 0, 0, 0.9 );
        mesh = new THREE.Mesh(geometry, material);
        mesh.castShadow = true;
        mesh.quaternion.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI / 2);
        mesh.receiveShadow = true;

        mesh.name = "ground plane";
        scene.add(mesh);

        setScene("Cubes");
        setFracturePattern('Plane');

        renderer = new THREE.WebGLRenderer({
          antialias : true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(scene.fog.color);

        container.appendChild(renderer.domElement);

        renderer.gammaInput = true;
        renderer.gammaOutput = true;
        renderer.shadowMapEnabled = true;

        window.addEventListener('resize', onWindowResize, false);

        window.addEventListener("mousemove", onMouseMove, false);
        window.addEventListener("mousedown", onMouseDown, false);
        window.addEventListener("mouseup", onMouseUp, false);
      }

      function setScene(scene_name) {
        for (var m in meshes) {
          scene.remove(meshes[m]);
        }
        meshes = [];

        for (var b in bodies) {
          world.remove(bodies[b]);
        }
        bodies = [];

        switch(scene_name) {
          case "Cubes":
            // cubes
            var cubeGeo;
            var cubeMaterial = new THREE.MeshPhongMaterial({
              color : 0x3333ff
            });
            var mass = 5, radius = 1.3;
            boxShape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5));

            for (var i = 0; i < n_cubes; i++) {
              cubeGeo = new THREE.BoxGeometry(1, 1, 1);
              cubeMesh = new THREE.Mesh(cubeGeo, cubeMaterial);
              cubeMesh.castShadow = true;
              meshes.push(cubeMesh);
              cubeMesh.name = "cube " + i;
              scene.add(cubeMesh);

              // boxes
              boxBody = new CANNON.Body({
                mass : mass
              });
              boxBody.addShape(boxShape);
              boxBody.position.y = (i+1) * 1.25;

              boxBody.name = "Box Body " + i;
              world.add(boxBody);
              bodies.push(boxBody);
            }

            break;
          case "Pillars":
            loader.load("rsc/fracture_templates/pillar-simple.js", function(geometry) {

              var material = new THREE.MeshPhongMaterial({
                color : 0x3333ff
              });
              var mass = 5, radius = 1.3;
              boxShape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5));

              for (var i = 0; i < n_cubes; i++) {

                var mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                meshes.push(mesh);
                mesh.name = "pillar  " + i;
                scene.add(mesh);

                // boxes
                var body = new CANNON.Body({
                  mass : mass
                });

                // Add to compound
                body.addShape(getConvexHullFromGeometry(geometry));

                body.position.z = i * 2 - 2;
                body.position.y = (n_cubes-i+1) * .25;

                body.name = "Box Body " + i;
                world.add(body);
                bodies.push(body);
              }

            });
            break;

        }
      }

      function setFracturePattern(pattern) {

        if (fracturePattern) {
          scene.remove(fracturePattern);
        }

        switch(pattern) {
          case "Sphere":

            var shape = new THREE.SphereGeometry(0.2, 8, 8);
            fracturePattern = new THREE.Mesh(shape, markerMaterial);
            fracturePattern.name = "click marker";
            scene.add(fracturePattern);

            break;
          case "Plane":
            var shape = new THREE.PlaneGeometry(1, 1, 1);
            fracturePattern = new THREE.Mesh(shape, markerMaterial);
            fracturePattern.rotation.set(Math.PI / 2, 0, 0);
            fracturePattern.scale.copy(new THREE.Vector3(2, 2, 2));
            fracturePattern.name = "fracture pattern";
            scene.add(fracturePattern);

            break;

        }

      }

      function moveFracturePattern(x, y, z) {

        fracturePattern.visible = true;
        fracturePattern.position.set(x, y, z);
      }

      function removeFracturePattern() {
        fracturePattern.visible = false;
      }

      function getConvexHullFromGeometry(geometry,scale) {
      	var scale = scale || 1;
      	
        var verts = [], faces = [];

        // Get vertices
        for (var j = 0; j < geometry.vertices.length; j++) {
          verts.push(new CANNON.Vec3(geometry.vertices[j].x * scale, geometry.vertices[j].y * scale, geometry.vertices[j].z * scale));
        }

        // Get faces
        for (var j = 0; j < geometry.faces.length; j++) {
          faces.push([geometry.faces[j].a, geometry.faces[j].b, geometry.faces[j].c]);
        }

        // Construct polyhedron
        return new CANNON.ConvexPolyhedron(verts, faces);
      }

      function onMouseMove(e) {

        var entity = findNearestIntersectingObject(e.clientX, e.clientY, camera, meshes);

        if (entity) {
          var pos = entity.point;
          setScreenPerpCenter(pos, camera);
          $('html').css('cursor', 'none');

          // Move and project on the plane
          if (gplane) {
            var pos = projectOntoPlane(e.clientX, e.clientY, gplane, camera);

            if (pos) {

              moveFracturePattern(pos.x, pos.y, pos.z, scene);
              // moveJointToPoint(pos.x, pos.y, pos.z);
            }
          }
        } else {
          fracturePattern.visible = false;
          $('html').css('cursor', '');
        }
      }

      function onMouseDown(e) {
        // Find mesh from a ray
        var entity = findNearestIntersectingObject(e.clientX, e.clientY, camera, meshes);
        if (!entity) {
          return;
        }

        var pos = entity.point;

        var obj = entity.object;
        scene.remove(obj);

        // remove from meshes
        for (var i in meshes) {
          if (meshes[i] == obj) {
            meshes.splice(i, 1);
            world.remove(bodies[i]);
            bodies.splice(i, 1);

            break;
          }
        }

        var mass = 5;

        for (var i = 0; i < 2; i++) {
          for (var j = 0; j < 2; j++) {
            for (var k = 0; k < 2; k++) {

              var material = new THREE.MeshPhongMaterial({
                color : 0xff0000
              });
              var hue = Math.random();
              //(Math.log(1 / obj.scale.x) / Math.LN2 / 6);

              material.color.setHSL(hue, 1, 0.5);

              var mesh = new THREE.Mesh(obj.geometry, material);
              mesh.castShadow = true;
              mesh.scale.copy(new THREE.Vector3(obj.scale.x * .5, obj.scale.y * .5, obj.scale.z * .5));
              //cubeMesh.rotation.copy(obj.rotation);

              mesh.name = obj.name + "_" + (i + j + k);

              meshes.push(mesh);

              // var shape = new CANNON.Box(new CANNON.Vec3(mesh.scale.x / 2, mesh.scale.y / 2, mesh.scale.z / 2));
              var shape =  getConvexHullFromGeometry(obj.geometry);
              var body = new CANNON.Body({
                mass : mass
              });

              //boxBody.quaternion.setFromEuler(obj.rotation);
              body.quaternion.setFromAxisAngle(new CANNON.Vec3(obj.rotation.x, obj.rotation.y, obj.rotation.z), 1);

              body.addShape(shape);
              body.position.copy(obj.position);
              body.quaternion.copy(obj.quaternion);
              body.position.x += (obj.scale.x / 2) * (i - 0.5);
              body.position.y += (obj.scale.y / 2) * (j - 0.5);
              body.position.z += (obj.scale.z / 2) * (k - 0.5);

              body.name = obj.name + "-" + (i + j + k);

              world.add(body);
              bodies.push(body);

              scene.add(mesh);

            }
          }
        }

        // if (pos && entity.object.geometry instanceof THREE.BoxGeometry) {
        // constraintDown = true;
        // // Set marker on contact point
        // setClickMarker(pos.x, pos.y, pos.z, scene);
        //
        // // Set the movement plane
        // setScreenPerpCenter(pos, camera);
        //
        // var idx = meshes.indexOf(entity.object);
        // if (idx !== -1) {
        // addMouseConstraint(pos.x, pos.y, pos.z, bodies[idx]);
        // }
        // }
      }

      // This function creates a virtual movement plane for the mouseJoint to move in
      function setScreenPerpCenter(point, camera) {
        // If it does not exist, create a new one
        if (!gplane) {
          var planeGeo = new THREE.PlaneGeometry(100, 100);
          var plane = gplane = new THREE.Mesh(planeGeo, material);
          plane.visible = false;
          // Hide it..
          plane.name = "invisible movement plane for mousejoint";
          scene.add(gplane);
        }

        // Center at mouse position
        gplane.position.copy(point);

        // Make it face toward the camera
        gplane.quaternion.copy(camera.quaternion);
      }

      function onMouseUp(e) {
        return;

        constraintDown = false;
        // remove the marker
        removeClickMarker();

        // Send the remove mouse joint to server
        // removeJointConstraint();
      }

      var lastx, lasty, last;
      function projectOntoPlane(screenX, screenY, thePlane, camera) {
        var x = screenX;
        var y = screenY;
        var now = new Date().getTime();
        // project mouse to that plane
        var hit = findNearestIntersectingObject(screenX, screenY, camera, [thePlane]);
        // [thePlane]);
        lastx = x;
        lasty = y;
        last = now;
        if (hit) {
          return hit.point;
        }
        return false;
      }

      function findNearestIntersectingObject(clientX, clientY, camera, objects) {
        // Get the picking ray from the point
        var raycaster = getRayCasterFromScreenCoord(clientX, clientY, camera, projector);

        // Find the closest intersecting object
        // Now, cast the ray all render objects in the scene to see if they collide. Take the closest one.
        var hits = raycaster.intersectObjects(objects);
        var closest = false;
        if (hits.length > 0) {
          closest = hits[0];
        }

        return closest;
      }

      // Function that returns a raycaster to use to find intersecting objects
      // in a scene given screen pos and a camera, and a projector
      function getRayCasterFromScreenCoord(screenX, screenY, camera, projector) {
        var mouse3D = new THREE.Vector3();
        // Get 3D point form the client x y
        mouse3D.x = (screenX / window.innerWidth) * 2 - 1;
        mouse3D.y = -(screenY / window.innerHeight) * 2 + 1;
        mouse3D.z = 0.5;
        return projector.pickingRay(mouse3D, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        //controls.handleResize();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);
        //controls.update();
        updatePhysics();
        render();
      }

      function updatePhysics() {
        world.step(dt);
        for (var i = 0; i !== meshes.length; i++) {
          meshes[i].position.copy(bodies[i].position);
          meshes[i].quaternion.copy(bodies[i].quaternion);
        }
      }

      function render() {
        renderer.render(scene, camera);
      }

      function initCannon() {
        // Setup our world
        world = new CANNON.World();
        world.quatNormalizeSkip = 0;
        world.quatNormalizeFast = false;

        world.gravity.set(0, -10, 0);
        world.broadphase = new CANNON.NaiveBroadphase();

        // Create a plane
        var groundShape = new CANNON.Plane();
        var groundBody = new CANNON.Body({
          mass : 0
        });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);

        groundBody.name = "ground plane body";
        world.add(groundBody);

        // Joint body
        // var shape = new CANNON.Sphere(0.1);
        // jointBody = new CANNON.Body({
        // mass : 0
        // });
        // jointBody.addShape(shape);
        // jointBody.collisionFilterGroup = 0;
        // jointBody.collisionFilterMask = 0;
        // world.add(jointBody)
      }

      function addMouseConstraint(x, y, z, body) {
        // The cannon body constrained by the mouse joint
        constrainedBody = body;

        // Vector to the clicked point, relative to the body
        var v1 = new CANNON.Vec3(x, y, z).vsub(constrainedBody.position);

        // Apply anti-quaternion to vector to tranform it into the local body coordinate system
        var antiRot = constrainedBody.quaternion.inverse();
        pivot = antiRot.vmult(v1);
        // pivot is not in local body coordinates

        // Move the cannon click marker particle to the click position
        jointBody.position.set(x, y, z);

        // Create a new constraint
        // The pivot for the jointBody is zero
        mouseConstraint = new CANNON.PointToPointConstraint(constrainedBody, pivot, jointBody, new CANNON.Vec3(0, 0, 0));

        // Add the constriant to world
        world.addConstraint(mouseConstraint);
      }

      // This functions moves the transparent joint body to a new postion in space
      function moveJointToPoint(x, y, z) {
        // Move the joint body to a new position
        jointBody.position.set(x, y, z);
        mouseConstraint.update();
      }

      function removeJointConstraint() {
        // Remove constriant from world
        world.removeConstraint(mouseConstraint);
        mouseConstraint = false;
      }

		</script>
	</body>
</html>
